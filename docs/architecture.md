# グループTODO - アーキテクチャ設計書

## ドキュメント概要

- **作成日**: 2025-11-06
- **対象**: グループTODOアプリのアーキテクチャ設計
- **目的**: 設計思想・設計原則を記録する

---

## 1. アーキテクチャ概要

### 1.1 アプリケーションの目的

家族や知人とリアルタイムでTODOを共有・管理できるグループTODOアプリ。
買い物リストや家事の管理など、日常的なタスク管理を複数人で効率的に行う。

### 1.2 基本設計方針

**オンライン必須・DB接続前提**

- Supabaseデータベースへの接続が必須で動作する
- DB接続失敗時のローカルデータフォールバック機能は実装しない
- API接続失敗・DB接続失敗時はエラー画面に遷移し、正常動作を停止する
- オフライン時やネットワーク障害時はアプリ使用不可として扱う

**シンプル・保守性重視**

- 複雑な状態管理ライブラリを使わず、StatefulWidget + Service Layerで実装
- 小規模グループ（家族・同居人）向けのシンプルな設計
- 誰でも簡単に使える直感的なUI

**デバイスベース認証**

- メールアドレス・電話番号の登録不要
- デバイスに紐づく認証方式
- データ引き継ぎ機能でデバイス変更に対応

**招待制・クローズドな設計**

- SNS要素なし
- 知り合いのみを招待するクローズドなグループ管理

### 1.3 アーキテクチャの特徴

- **Service-based Architecture**: ビジネスロジックをService層に集約
- **Supabase中心設計**: PostgreSQL + Edge Functions + Storage + リアルタイム同期を活用
- **共通処理の統一**: API呼び出し・エラーハンドリング・デバイスID取得などを共通化
- **環境分離**: Flavor（dev/stg/prod）による環境ごとの設定管理

---

## 2. 技術選定の思想

### 2.1 Flutter選定理由

**クロスプラットフォーム対応**

- iOS・Android・Webを単一コードベースで開発
- 小規模チームでの効率的な開発

**Material Design 3対応**

- モダンなUIコンポーネント
- 直感的なユーザー体験

### 2.2 Supabase選定理由

**オールインワンBaaS**

- PostgreSQL（データベース）
- Edge Functions（サーバーレス処理）
- Storage（ファイル保存）
- リアルタイム同期（将来的な拡張に対応）

**PostgreSQLの信頼性**

- ACID特性による高いデータ整合性
- リレーショナルデータベースによる柔軟なクエリ

**Row Level Security (RLS)**

- データベースレベルでのアクセス制御
- セキュリティの高い設計

### 2.3 デバイスベース認証を選んだ理由

**ユーザー登録の簡素化**

- メールアドレス・パスワード不要
- アプリ起動時に自動的にユーザー作成
- 家族・知人間での利用に特化

**データ引き継ぎ機能での対応**

- デバイス変更時はユーザーID + パスワードで引き継ぎ
- 紛失時の対策も可能

---

## 3. レイヤー構成とパターン

### 3.1 Service-based Architecture採用理由

**シンプルさ重視**

- Clean Architectureのような複雑な層分離は不要
- 小規模アプリに適したシンプルな構造
- Service層にビジネスロジックを集約

**保守性の向上**

- 各機能ごとにServiceを分離（UserService、GroupService、TodoServiceなど）
- 責務の明確化
- テストの容易性

### 3.2 状態管理の考え方

**StatefulWidget + Service Layer**

- Providerなどの状態管理ライブラリは使用しない
- 画面ごとのStatefulWidgetで状態を管理
- Service層を通じてデータ取得・更新

**データキャッシュの活用**

- DataCacheServiceでアプリ全体のデータをキャッシュ
- 画面間でのデータ共有
- API呼び出しの最小化

### 3.3 データフローの設計思想

**単方向データフロー**

1. UI層（Widget）がユーザー操作を受け取る
2. Service層を呼び出す
3. Service層がEdge Functionを呼び出す
4. レスポンスをキャッシュに保存
5. UIを更新（setState）

**リアルタイム同期の考え方**

- 現状は手動リフレッシュ
- 将来的にSupabase Realtimeを活用する拡張性を確保

---

## 4. 共通処理とユーティリティ設計

### 4.1 ApiClient - Edge Function呼び出しの統一管理

**設計思想**

- すべてのEdge Function呼び出しをApiClientに集約
- 共通処理を一箇所で管理

**共通化された処理**

- 共通ヘッダーの設定（Authorization, Content-Type）
- メンテナンスモードチェックの一元化
- エラーハンドリングの統一
- 未送信エラーログの自動送信試行（log-error API呼び出し時は除外）

**メンテナンスモード・エラーの統一処理**

- すべてのAPI呼び出しで自動的にチェック
- メンテナンスモード時はMaintenanceDialogを表示
- システムエラー時はエラーダイアログを表示

### 4.2 DeviceIdHelper - デバイスID取得の共通化

**設計思想**

- プラットフォーム別のデバイスID取得ロジックを一元化
- SharedPreferencesでキャッシュ管理

**プラットフォーム別の処理**

- iOS: identifierForVendor
- Android: androidId
- Web: UUID生成
- その他: UUID生成

**キャッシュ戦略**

- 初回取得時にSharedPreferencesに保存
- 2回目以降はキャッシュから取得

### 4.3 ContentValidator - コンテンツバリデーションの共通化

**設計思想**

- ユーザー入力のバリデーションロジックを共通化
- クライアント側での事前チェック（サーバー側でも検証）

**検証内容**

- 個人情報パターンチェック（メールアドレス、電話番号）
- NGワードチェック

### 4.4 StorageHelper - SharedPreferencesのラッパー

**設計思想**

- SharedPreferencesの操作を共通化
- キーの一元管理

**管理データ**

- ユーザーID
- 表示名
- 最終同期時刻

---

## 5. デバイス認証とユーザー管理

### 5.1 デバイスID取得の実装方針

**プラットフォーム別の違いへの対応**

- iOS: `identifierForVendor`を使用（ベンダー単位で一意）
- Android: `androidId`を使用（デバイス固有）
- Web: UUIDを生成してSharedPreferencesに保存

**キャッシュによる安定性**

- 初回取得後はSharedPreferencesにキャッシュ
- アプリ再起動後も同じデバイスIDを維持

### 5.2 データ引き継ぎ機能の設計思想

**ユーザーID + パスワード方式**

- ユーザーID（display_id）: 8桁英数字のランダムID
- パスワード: 8文字以上の任意の文字列
- パスワードハッシュ（bcrypt）をデータベースに保存

**引き継ぎフロー**

1. 旧デバイスで引き継ぎパスワードを設定
2. ユーザーIDとパスワードをメモ
3. 新デバイスでユーザーID + パスワードを入力
4. 認証成功後、新デバイスIDでユーザー情報を更新

**セキュリティ**

- パスワードはbcryptでハッシュ化
- デバイスIDは新デバイスのものに上書き

---

## 6. データキャッシュとオフライン対応

### 6.1 DataCacheServiceの設計思想

**アプリ全体でのデータ共有**

- ユーザー情報、グループ情報、TODO情報をメモリにキャッシュ
- 画面間でのデータ共有
- API呼び出しの最小化

**キャッシュ戦略**

- アプリ起動時に初期化（initialize-user-cache Edge Function）
- データ更新時にキャッシュを更新
- 手動リフレッシュで最新データを取得

### 6.2 SharedPreferencesの活用

**軽量データの永続化**

- ユーザーID、表示名などの認証情報
- アプリ設定
- 最終同期時刻

**キャッシュとの使い分け**

- SharedPreferences: 永続化が必要な軽量データ
- DataCacheService: アプリ実行中の一時的なデータ

### 6.3 オフライン対応の方針

**現状**

- オンライン必須の設計
- オフライン時はアプリ使用不可

**将来的な拡張**

- Supabase Realtimeによるリアルタイム同期
- ローカルストレージへの一時保存
- ネットワーク復帰時の自動同期

---

## 7. エラーハンドリング設計

### 7.1 アプリ側のエラーハンドリング方針

**統一されたエラー処理**

- ApiClientで共通的にエラーをキャッチ
- エラー種別に応じた適切な処理

**エラー種別**

- メンテナンスモード: MaintenanceDialogを表示
- システムエラー: エラーダイアログを表示
- APIエラー: ApiExceptionをスロー
- ネットワークエラー: ApiExceptionをスロー

### 7.2 ErrorLogServiceの役割

**エラーの自動記録**

- アプリ内で発生したエラーを自動的に記録
- サーバーに送信してログ保存

**記録情報**

- エラーID
- エラー種別
- エラーメッセージ
- スタックトレース
- 発生画面
- ユーザーID
- 発生日時

### 7.3 未送信エラーログの自動送信

**設計思想**

- ネットワークエラーで送信失敗したエラーログを保存
- 次回API呼び出し時に自動的に再送信試行

**実装**

- ApiClientの`callFunction`メソッド内で`sendPendingErrors`を呼び出し
- log-error API呼び出し時は除外（無限ループ防止）

### 7.4 エラーダイアログ表示の統一化

**MaintenanceDialog**

- メンテナンスモード時・システムエラー時に表示
- OKボタンのみ
- ユーザーは操作を継続できない

### 7.5 エラー処理の原則

**エラーを隠蔽しない**

- try-catchでエラーをキャッチしても、ユーザーに適切にフィードバックする
- エラーを無視して正常処理を継続しない
- ErrorLogServiceで必ずログを記録する
- サイレントエラー（ユーザーに通知せずエラーを握りつぶす）を避ける

**Exception情報を画面に直接表示しない**

- スタックトレース、内部エラーメッセージは画面に表示しない
- ユーザーフレンドリーなメッセージに変換する
- 詳細情報はErrorLogServiceでログに記録
- セキュリティリスクの回避（内部実装の露出を防ぐ）

**HTTPステータスコードの適切な使用**

- 200以外のステータスコードを正常処理として扱わない
- 404はAPI自体が存在しない場合のみ使用（データ未発見では使用しない）
- ビジネスロジックエラー（招待が既に承認済み、権限不足等）は200 + `success: false`で返す
- クライアント側は`response['success']`を必ず確認してから処理を継続
- サーバーエラー（500番台）は予期しないエラーとして扱う

---

## 8. データ設計の思想

### 8.1 PostgreSQLでのデータ構造設計原則

**リレーショナルデータベースの活用**

- 正規化されたテーブル設計
- 外部キー制約による整合性の担保
- CASCADE削除による関連データの自動削除

**デバイスベース認証に基づく設計**

- usersテーブルに`device_id`カラム（UNIQUE制約）
- `display_id`（8桁英数字）による招待・引き継ぎ

### 8.2 主要なリレーションシップ設計思想

**ユーザーとグループの関係**

- groups: オーナーID（`owner_id`）を持つ
- group_members: グループとユーザーの多対多関係
- role（owner/member）による権限管理

**TODOの所属と担当**

- todos: グループIDを持つ（グループに所属）
- todo_assignments: TODOと担当者の多対多関係
- 複数人への担当割り当てが可能

**定期TODOの設計**

- recurring_todos: 定期TODO設定
- recurring_todo_assignments: 定期TODOの担当者
- todosテーブルに`recurring_todo_id`を持つ（生成元の記録）

**グループ招待の設計**

- group_invitations: 招待情報
- status（pending/accepted/rejected）による状態管理
- 承認制の実現

### 8.3 文字数制限の設計

**データベース制約**

- グループ名: 50文字
- グループ説明: 200文字
- TODOタイトル: 100文字
- TODO説明: 200文字

**UI側の制限**

- 画面では`maxLength`で制限
- データベース制約よりも厳しい場合あり（グループ名: 15文字など）

---

## 9. バックエンド設計思想

### 9.1 Edge Functionsによる集中管理

**サーバーレスアーキテクチャ**

- Supabase Edge Functionsを活用
- 機能ごとに独立したFunction
- スケーラブルな設計

**Edge Functions の役割**

- ビジネスロジックの実行
- データベース操作
- コンテンツポリシー検証
- エラーハンドリング

### 9.2 メンテナンスモードの統一チェック

**設計思想**

- すべてのEdge Functionで最初にメンテナンスモードをチェック
- メンテナンス中は`status: 'maintenance'`を返す
- ApiClientで統一的に処理

**実装パターン**

```typescript
// 全Edge Functionで共通
const maintenanceCheck = await checkMaintenanceMode();
if (maintenanceCheck.isUnderMaintenance) {
  return new Response(
    JSON.stringify({
      status: 'maintenance',
      message: maintenanceCheck.message,
    }),
    { headers: { 'Content-Type': 'application/json' }, status: 200 }
  );
}
```

### 9.3 コンテンツポリシー検証のサーバーサイド実装

**設計思想**

- クライアント側で事前チェック（ContentValidator）
- サーバー側で厳密に検証
- NGワードリストの一元管理

**検証内容**

- 個人情報（メールアドレス、電話番号）
- 禁止ワード
- 差別的表現・誹謗中傷

---

## 10. セキュリティ設計思想

### 10.1 Row Level Security (RLS) ポリシー

**データベースレベルのアクセス制御**

- PostgreSQLのRLS機能を活用
- ユーザーは自分が所属するグループのデータのみアクセス可能
- Edge Functionsを通じた操作でもRLSが適用される

**主要なRLSポリシー**

- グループメンバーのみがグループ情報を参照可能
- グループメンバーのみがTODO情報を参照・更新可能
- 定期TODO、コメントも同様

### 10.2 コンテンツバリデーション

**二重のバリデーション**

- クライアント側: ContentValidatorによる事前チェック
- サーバー側: Edge Functionsでの厳密な検証

**検証の目的**

- 個人情報の漏洩防止
- 不適切なコンテンツの投稿防止
- サービス品質の維持

### 10.3 認証の設計

**デバイスIDベースの認証**

- デバイスIDをキーとしてユーザーを特定
- パスワード不要のシンプルな認証

**データ引き継ぎのセキュリティ**

- パスワードはbcryptでハッシュ化（コスト: 10）
- ユーザーID + パスワードによる二要素認証

---

## 11. 環境管理とデプロイ

### 11.1 Flavorによる環境分離

**3つの環境**

- development (dev): 開発環境
- staging (stg): ステージング環境
- production (prod): 本番環境

**環境ごとの設定**

- Supabase URL
- Supabase Anon Key
- 広告表示ON/OFF

### 11.2 環境設定の管理

**environments.jsonによる一元管理**

- `assets/config/environments.json`に全環境の設定を記載
- EnvironmentConfigクラスで設定を読み込み
- アプリ起動時に環境を指定

**設定項目**

- supabaseUrl
- supabaseAnonKey
- showAds（広告表示フラグ）

### 11.3 マイグレーション管理方針

**DDLとマイグレーションの分離**

- `database/ddl/01_create_tables.sql`: 最新のテーブル定義
- `database/migrations/`: 変更履歴をマイグレーションファイルで管理

**マイグレーション適用手順**

1. マイグレーションファイルを作成
2. DEV環境に適用
3. STG環境に適用
4. PROD環境に適用
5. DDLファイルに反映

---

## 12. コーディング規約と実装原則

### 12.1 ハードコードの禁止

**環境依存の値は環境変数で管理**

- Supabase URL・APIキーは`environments.json`で管理
- 環境（dev/stg/prod）ごとに異なる値を設定
- コード内に直接URLやキーを書かない

**マジックナンバーは定数化**

- 数値リテラルの直接使用を避ける
- 意味のある定数名を付ける
- 変更が必要な場合は一箇所で修正できるようにする

**文字列リテラルの適切な管理**

- 繰り返し使用される文字列は定数化
- タイポのリスクを減らす
- 一元管理による保守性向上

### 12.2 定数管理

**画面遷移のルート名**

- ルート名は定数として定義
- タイポによるバグを防止
- リファクタリングの容易性

**エラーメッセージの一元管理**

- ユーザー向けメッセージは定数化
- 多言語対応の準備
- 一貫性のあるメッセージング

**設定値の一元管理**

- アプリ設定は一箇所で管理
- 変更時の影響範囲を最小化
- 設定値の可視性向上

### 12.3 コメント規約

**開発中の一時的なコメントは残さない**

- 「新API」「新しい方法」等の表現は避ける
- 後から見たら新しくも何ともない
- 実装の意図・理由を記載する

**わかりやすいコメント**

- なぜそうしたか（Why）を記載
- 何をしているか（What）は明白なら不要
- 複雑なロジックには必ず説明を追加

---

**最終更新日**: 2025-11-07
